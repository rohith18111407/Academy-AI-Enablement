[
  {
    "model": "GPT-4o",
    "provider": "openai",
    "category": "AppDev (Code Generation)",
    "prompt_id": "appdev_fizzbuzz",
    "task_description": "Python FizzBuzz",
    "prompt": "Write a clean Python function for FizzBuzz from 1 to 100.",
    "response_text": "ERROR: OpenAI quota exceeded. Skipping evaluation for this model.",
    "latency_ms": null,
    "rating": "",
    "comments": ""
  },
  {
    "model": "GPT-4o",
    "provider": "openai",
    "category": "Data (SQL Generation & Analysis)",
    "prompt_id": "data_sql_top_customers",
    "task_description": "Top Customers by Revenue",
    "prompt": "Write an optimized SQL query to get top 5 customers by revenue in the last 6 months.",
    "response_text": "ERROR: OpenAI quota exceeded. Skipping evaluation for this model.",
    "latency_ms": null,
    "rating": "",
    "comments": ""
  },
  {
    "model": "GPT-4o",
    "provider": "openai",
    "category": "DevOps (Infrastructure Automation)",
    "prompt_id": "devops_terraform_ecs",
    "task_description": "Terraform ECS Deployment",
    "prompt": "Create Terraform code to deploy a Docker application on AWS ECS with an Application Load Balancer.",
    "response_text": "ERROR: OpenAI quota exceeded. Skipping evaluation for this model.",
    "latency_ms": null,
    "rating": "",
    "comments": ""
  },
  {
    "model": "Claude Sonnet (Bedrock)",
    "provider": "anthropic",
    "category": "AppDev (Code Generation)",
    "prompt_id": "appdev_fizzbuzz",
    "task_description": "Python FizzBuzz",
    "prompt": "Write a clean Python function for FizzBuzz from 1 to 100.",
    "response_text": "Sure, here's a clean Python function for FizzBuzz from 1 to 100:\n\n```python\ndef fizz_buzz():\n    for num in range(1, 101):\n        if num % 3 == 0 and num % 5 == 0:\n            print(\"FizzBuzz\")\n        elif num % 3 == 0:\n            print(\"Fizz\")\n        elif num % 5 == 0:\n            print(\"Buzz\")\n        else:\n            print(num)\n```\n\nAnd to call the function:\n\n```python\nfizz_buzz()\n```\n\nThis function uses a `for` loop to iterate over the numbers from 1 to 100. For each number, it checks the following conditions:\n\n1. If the number is divisible by both 3 and 5, it prints \"FizzBuzz\".\n2. If the number is divisible by 3, it prints \"Fizz\".\n3. If the number is divisible by 5, it prints \"Buzz\".\n4. If the number is not divisible by either 3 or 5, it prints the number itself.\n\nThe modulo operator `%` is used to check if a number is divisible by another number. If the remainder of the division is 0, then the number is divisible.\n\nHere's the output when you run the `fizz_buzz()` function:\n\n```\n1\n2\nFizz\n4\nBuzz\nFizz\n7\n8\nFizz\nBuzz\n11\nFizz\n13\n14\nFizzBuzz\n16\n...\n...\n...\nBuzz\n98\nFizz\nBuzz\n```\n\nThis implementation is clean, concise, and adheres to the Python coding style guidelines (PEP 8).",
    "latency_ms": 6144.49,
    "rating": "",
    "comments": ""
  },
  {
    "model": "Claude Sonnet (Bedrock)",
    "provider": "anthropic",
    "category": "Data (SQL Generation & Analysis)",
    "prompt_id": "data_sql_top_customers",
    "task_description": "Top Customers by Revenue",
    "prompt": "Write an optimized SQL query to get top 5 customers by revenue in the last 6 months.",
    "response_text": "To get the top 5 customers by revenue in the last 6 months, you can use the following SQL query:\n\n```sql\nSELECT\n    c.customer_id,\n    c.customer_name,\n    SUM(o.total_amount) AS total_revenue\nFROM\n    customers c\n    JOIN orders o ON c.customer_id = o.customer_id\nWHERE\n    o.order_date >= DATE_SUB(CURRENT_DATE(), INTERVAL 6 MONTH)\nGROUP BY\n    c.customer_id,\n    c.customer_name\nORDER BY\n    total_revenue DESC\nLIMIT 5;\n```\n\nHere's a breakdown of the query:\n\n1. `SELECT` clause: Selects the `customer_id`, `customer_name`, and the sum of `total_amount` from the orders table as `total_revenue`.\n\n2. `FROM` clause: Joins the `customers` and `orders` tables based on the `customer_id` column.\n\n3. `WHERE` clause: Filters the orders to only include those made in the last 6 months. The `DATE_SUB` function is used to subtract 6 months from the current date.\n\n4. `GROUP BY` clause: Groups the results by `customer_id` and `customer_name` to calculate the total revenue for each customer.\n\n5. `ORDER BY` clause: Sorts the results in descending order based on the `total_revenue` column.\n\n6. `LIMIT` clause: Limits the result set to the top 5 customers.\n\nThis query will return the top 5 customers along with their `customer_id`, `customer_name`, and `total_revenue` (sum of the `total_amount` from orders in the last 6 months).\n\nNote: Make sure that the `customers`, `orders`, and the relevant columns (`customer_id`, `customer_name`, `total_amount`, `order_date`) exist in your database schema for this query to work correctly.",
    "latency_ms": 6142.7,
    "rating": "",
    "comments": ""
  },
  {
    "model": "Claude Sonnet (Bedrock)",
    "provider": "anthropic",
    "category": "DevOps (Infrastructure Automation)",
    "prompt_id": "devops_terraform_ecs",
    "task_description": "Terraform ECS Deployment",
    "prompt": "Create Terraform code to deploy a Docker application on AWS ECS with an Application Load Balancer.",
    "response_text": "Sure, here's an example of Terraform code to deploy a Docker application on AWS ECS with an Application Load Balancer:\n\n```hcl\n# Define the AWS provider\nprovider \"aws\" {\n  region = \"us-west-2\" # Replace with your desired AWS region\n}\n\n# Create a VPC\nresource \"aws_vpc\" \"main\" {\n  cidr_block = \"10.0.0.0/16\"\n}\n\n# Create subnets\nresource \"aws_subnet\" \"public_subnets\" {\n  count                   = 2\n  vpc_id                  = aws_vpc.main.id\n  cidr_block              = \"10.0.${count.index}.0/24\"\n  availability_zone       = data.aws_availability_zones.available.names[count.index]\n  map_public_ip_on_launch = true\n}\n\n# Create an internet gateway\nresource \"aws_internet_gateway\" \"gw\" {\n  vpc_id = aws_vpc.main.id\n}\n\n# Create a route table for public subnets\nresource \"aws_route_table\" \"public_rt\" {\n  vpc_id = aws_vpc.main.id\n\n  route {\n    cidr_block = \"0.0.0.0/0\"\n    gateway_id = aws_internet_gateway.gw.id\n  }\n}\n\n# Associate public subnets with the public route table\nresource \"aws_route_table_association\" \"public_assoc\" {\n  count          = 2\n  subnet_id      = aws_subnet.public_subnets[count.index].id\n  route_table_id = aws_route_table.public_rt.id\n}\n\n# Create an ECS cluster\nresource \"aws_ecs_cluster\" \"main\" {\n  name = \"my-ecs-cluster\"\n}\n\n# Create an ECS task definition\nresource \"aws_ecs_task_definition\" \"app\" {\n  family                   = \"my-app\"\n  container_definitions    = file(\"task-definition.json\")\n  requires_compatibilities = [\"FARGATE\"]\n  network_mode             = \"awsvpc\"\n  cpu                      = 256\n  memory                   = 512\n}\n\n# Create an ECS service\nresource \"aws_ecs_service\" \"main\" {\n  name            = \"my-app-service\"\n  cluster         = aws_ecs_cluster.main.id\n  task_definition = aws_ecs_task_definition.app.arn\n  desired_count   = 2\n  launch_type     = \"FARGATE\"\n\n  network_configuration {\n    subnets          = aws_subnet.public_subnets[*].id\n    assign_public_ip = true\n    security_groups  = [aws_security_group.allow_http.id]\n  }\n\n  load_balancer {\n    target_group_arn = aws_lb_target_group.main.arn\n    container_name   = \"my-app\"\n    container_port   = 80\n  }\n}\n\n# Create an Application Load Balancer\nresource \"aws_lb\" \"main\" {\n  name               = \"my-alb\"\n  load_balancer_type = \"application\"\n  subnets            = aws_subnet.public_subnets[*].id\n  security_groups    = [aws_security_group.allow_http.id]\n}\n\n# Create a target group for the load balancer\nresource \"aws_lb_target_group\" \"main\" {\n  name        = \"my-tg\"\n  port        = 80\n  protocol    = \"HTTP\"\n  vpc_id      = aws_vpc.main.id\n  target_type = \"ip\"\n}\n\n# Create a listener for the load balancer\nresource \"aws_lb_listener\" \"front_end\" {\n  load_balancer_arn = aws_lb.main.arn\n  port              = \"80\"\n  protocol          = \"HTTP\"\n\n  default_action {\n    type             = \"forward\"\n    target_group_arn = aws_lb_target_group.main.arn\n  }\n}\n\n# Create a security group to allow HTTP traffic\nresource \"aws_security_group\" \"allow_http\" {\n  name        = \"allow-http",
    "latency_ms": 10501.89,
    "rating": "",
    "comments": ""
  },
  {
    "model": "Gemini 1.5 Pro",
    "provider": "google",
    "category": "AppDev (Code Generation)",
    "prompt_id": "appdev_fizzbuzz",
    "task_description": "Python FizzBuzz",
    "prompt": "Write a clean Python function for FizzBuzz from 1 to 100.",
    "response_text": "ERROR: 404 NOT_FOUND. {'error': {'code': 404, 'message': 'models/gemini-1.5-pro is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.', 'status': 'NOT_FOUND'}}",
    "latency_ms": null,
    "rating": "",
    "comments": ""
  },
  {
    "model": "Gemini 1.5 Pro",
    "provider": "google",
    "category": "Data (SQL Generation & Analysis)",
    "prompt_id": "data_sql_top_customers",
    "task_description": "Top Customers by Revenue",
    "prompt": "Write an optimized SQL query to get top 5 customers by revenue in the last 6 months.",
    "response_text": "ERROR: 404 NOT_FOUND. {'error': {'code': 404, 'message': 'models/gemini-1.5-pro is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.', 'status': 'NOT_FOUND'}}",
    "latency_ms": null,
    "rating": "",
    "comments": ""
  },
  {
    "model": "Gemini 1.5 Pro",
    "provider": "google",
    "category": "DevOps (Infrastructure Automation)",
    "prompt_id": "devops_terraform_ecs",
    "task_description": "Terraform ECS Deployment",
    "prompt": "Create Terraform code to deploy a Docker application on AWS ECS with an Application Load Balancer.",
    "response_text": "ERROR: 404 NOT_FOUND. {'error': {'code': 404, 'message': 'models/gemini-1.5-pro is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.', 'status': 'NOT_FOUND'}}",
    "latency_ms": null,
    "rating": "",
    "comments": ""
  },
  {
    "model": "DeepSeek R1 7B",
    "provider": "ollama",
    "category": "AppDev (Code Generation)",
    "prompt_id": "appdev_fizzbuzz",
    "task_description": "Python FizzBuzz",
    "prompt": "Write a clean Python function for FizzBuzz from 1 to 100.",
    "response_text": "To solve the FizzBuzz problem, we need to generate a sequence of numbers from 1 to 100 and replace each number with \"Fizz\", \"Buzz\", or \"FizzBuzz\" based on specific divisibility rules. Here's how we can approach it:\n\n### Approach\nThe goal is to iterate through numbers from 1 to 100 and apply the following rules:\n- Replace the number with \"FizzBuzz\" if it is divisible by both 3 and 5.\n- Replace the number with \"Fizz\" if it is divisible by 3 but not by 5.\n- Replace the number with \"Buzz\" if it is divisible by 5 but not by 3.\n- Otherwise, return the number as a string.\n\nThe approach involves:\n1. Creating an empty list to collect results.\n2. Looping through each number from 1 to 100.\n3. Checking each number against the divisibility rules in order (first for both 3 and 5, then individually for 3, followed by 5).\n4. Appending the appropriate string based on these checks to the result list.\n5. Finally, joining all elements of the result list into a single string separated by newlines.\n\n### Solution Code\n\n```python\ndef fizzbuzz():\n    result = []\n    for num in range(1, 101):\n        if num % 15 == 0:\n            result.append(\"FizzBuzz\")\n        elif num % 3 == 0:\n            result.append(\"Fizz\")\n        elif num % 5 == 0:\n            result.append(\"Buzz\")\n        else:\n            result.append(str(num))\n    return '\\n'.join(result)\n```\n\n### Explanation\n- The function `fizzbuzz` initializes an empty list `result` to store each line of output.\n- It uses a loop to iterate over numbers from 1 to 100 (inclusive).\n- For each number, it checks if the number is divisible by both 3 and 5 using modulo operation with 15. If true, \"FizzBuzz\" is added to `result`.\n- If not, it checks divisibility by 3, appending \"Fizz\" if true.\n- If neither of the above conditions are met, it checks for divisibility by 5, appending \"Buzz\".\n- If none of these conditions are satisfied, the number itself is converted to a string and added to `result`.\n- After processing all numbers, the function joins the list into a single string with newline separators and returns it.\n\nThis approach ensures that each number is processed efficiently, following the specified rules in an optimal order.",
    "latency_ms": 39015.35,
    "rating": "",
    "comments": ""
  },
  {
    "model": "DeepSeek R1 7B",
    "provider": "ollama",
    "category": "Data (SQL Generation & Analysis)",
    "prompt_id": "data_sql_top_customers",
    "task_description": "Top Customers by Revenue",
    "prompt": "Write an optimized SQL query to get top 5 customers by revenue in the last 6 months.",
    "response_text": "To find the top 5 customers by revenue over the last six months, you can use an SQL query that filters for the relevant time frame, aggregates their revenue, sorts the results, and limits the output.\n\n### Solution Code\n```sql\nSELECT \n    c1.customer_id AS CustomerID,\n    SUM(c1.amount) AS TotalRevenue\nFROM \n    customers c1\nJOIN \n    (SELECT customer_id, amount, DATE\u6dfb\u52a0\u65f6\u95f4 as RevenueDate FROM your_table_name) revenue_data\nON \n    c1.customer_id = revenue_data.customer_id AND revenue_data.RevenueDate >= '2023-08-01' AND revenue_data.RevenueDate < '2024-07-31'\nGROUP BY \n    c1.customer_id\nORDER BY \n    TotalRevenue DESC\nLIMIT 5;\n```\n\n### Explanation\n\n1. **Data Aggregation**:\n   - The query first joins the `customers` table with a table containing customer revenue data, filtering for transactions that occurred in the last six months.\n\n2. **Revenue Calculation**:\n   - It calculates the total revenue for each customer by summing up their transaction amounts using `SUM(c1.amount)`.\n\n3. **Time Frame Filtering**:\n   - The query ensures only transactions from the past six months are considered, using a date range filter (`DATE >= '2023-08-01'` and `DATE < '2024-07-31'`).\n\n4. **Sorting and Limiting Results**:\n   - The results are sorted in descending order based on the total revenue.\n   - The `LIMIT 5` clause restricts the output to the top five customers.\n\nThis approach ensures efficiency by aggregating data within the query, minimizing the amount of data transferred, and using appropriate SQL features for sorting and limiting results.",
    "latency_ms": 26129.07,
    "rating": "",
    "comments": ""
  },
  {
    "model": "DeepSeek R1 7B",
    "provider": "ollama",
    "category": "DevOps (Infrastructure Automation)",
    "prompt_id": "devops_terraform_ecs",
    "task_description": "Terraform ECS Deployment",
    "prompt": "Create Terraform code to deploy a Docker application on AWS ECS with an Application Load Balancer.",
    "response_text": "Here's a Terraform code snippet to deploy a Docker containerized application on AWS ECS with an Application Load Balancer (ALB):\n\n```terraform\n# ECS Task Module\nmodule ECSTaskModule\n\n  provide_aws:\n    region = {{ fact.aws.region }}\n    account = {{ fact.aws.account }}\n\n  task FargateTask {\n    name = \"Docker Application\"\n    state = \"running\"\n    arguments = [\n      \"{{ .application_name }}\",\n      \"{{ .container_image }}\"\n    ]\n    timeout = 300s\n\n    # ECS configuration\n    provide_aws.ECS.FargateTaskConfiguration:={{\n      imageName: \"{{ .container_image }}\",\n      taskDefinitionName: \"DockerApplication\",\n      kmsKeyName: \"{{ lookup( Terraform Lookup KMSKey, KeyName = {{ .kms_key_name }} ) }}\",\n      enableSsl: true,\n      ssl: {\n        certificateName: \"{{ .ec2 private CA certificate name }}\",\n        privateKeyName: \"{{ .ec2 private key name }}\"\n      },\n      taskTimeoutSeconds: 3600,\n      spotTask priority: 15\n    }}\n\n    # ECS Resources\n    provide_aws.ECS.CostAwareScaling:={{\n      scaleOn: \"cpu\",\n      minScale: 1,\n      maxScale: 5,\n      scalingWindow: 60s,\n      price: \"{{ .scaling_price }}\"\n    }}\n  }\nend\n\n# ALB Module\nmodule AlbModule\n\n  provide_aws:\n    region = {{ fact.aws.region }}\n    account = {{ fact.aws.account }}\n\n  alb ApplicationLoadBalancer {\n    name = \"DockerAppALB\"\n    type = \"application\"\n    protocol = \"https\"\n\n    # Bind to EC2 instances\n    provide_aws.EC2Instances:={{\n      launchTemplateId: \"{{ lookup( Terraform Lookup LaunchTemplateName, KeyName = {{ .launch_template_name }} ) }}\",\n      instanceCount: 1,\n      subnetId: \"{{ fact.aws.subnet_id }}\",\n      keyPairName: \"{{ lookup( Terraform Lookup KeyPair, KeyName = {{ .key_pair_name }} ) }}\"\n    }}\n    \n    # Bind to ECS tasks\n    provide_aws.ECS.ApplicationLoadBalancerTaskNeighbors:={{\n      enabled: true,\n      scaleOutBehavior: \"enable\"\n    }}\n  }\nend\n\n# Example ECS Task Definition (DockerApplication)\ntask Definition DockerApplication {\n  state = \"defined\"\n\n  resources = [\n    \"ecs\",\n    \"cost-aware-scaling\"\n  ]\n\n  costs = [\n    \"AWS::ECS::CostAwareScaling\"\n  ]\n}\n```\n\nTo use this code, follow these steps:\n\n1. **Create a Terraform Provider File**\n\n   Copy the above code into a new file named `provider/terraform/provider.tf`. This will be your provider file.\n\n2. **Generate the Provider Configuration**\n\n   Open a terminal and run:\n   ```bash\n   terraform provider init --var-file .terraform/provider.tf\n   ```\n   This creates a YAML configuration file in your project root directory with all the necessary provider configurations.\n\n3. **Run Terraform to Apply the Plan**\n\n   Run:\n   ```bash\n   terraform apply\n   ```\n   This deploys your ECS tasks and ALB based on the configuration in your provider file.\n\n### Explanation of Key Components:\n\n1. **ECS Task Module**:\n   - `FargateTask`: Defines an ECS task with Fargate capabilities.\n   - `provide_aws.ECS.FargateTaskConfiguration`: Configures the ECS task to start, stop, and terminate instances based on CPU utilization and scaling price.\n\n2. **ALB Module**:\n   - `ApplicationLoadBalancer`: Creates an ALB that binds traffic from your EC2 instances to the ECS tasks.\n   - `EC2Instances`: Specifies the EC2 instances (in this case, the same instance you're using for this script).\n   - `ECS.ApplicationLoadBalancerTaskNeighbors`: Configures how the ALB routes traffic to the ECS tasks.\n\n3. **Example ECS Task Definition**:\n   - This defines a basic task that can be scaled based on CPU usage and costs.\n\n### Example Configuration:\n\nTo use the provider, you would specify it in your Terraform config like this:\n\n```yaml\nmodule my_appModule {\n  module_name = \"my_app\"\n  base_dir = \"{{ .app_dir }}\"\n}\n\nprovider my_app_provider {\n  ECS = {{ lookup( Terraform Lookup ECSProvider, region = \"{{ .region }}\" ) }}\n  \n  task ECSTaskModule.FargateTask {\n    application_name = \"MyApp\"\n    container_image = \"your-container-image\"\n    kms_key_name = \"key-123456789\"\n  }\n}\n```\n\n### Notes:\n\n- **KMS Key**: Ensure you have a KMS key attached to your AWS account for secure key usage.\n- **EC2 Instances**: You can configure multiple EC2 instances as sources of traffic to the ECS tasks.\n- **Scaling Price**: Adjust this based on your cost model and desired scaling behavior.\n\nThis code provides a basic template that you can customize according to your specific application requirements.",
    "latency_ms": 41640.47,
    "rating": "",
    "comments": ""
  }
]